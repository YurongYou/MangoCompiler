package ASTBuilder;

import AST.*;
import Exceptions.*;
import Gadgets.*;
import Gadgets.Symbol.FuncSymbol;
import Gadgets.Symbol.Symbol;
import Gadgets.Symbol.VarSymbol;
import Gadgets.Type.ArrayType;
import Gadgets.Type.ClassType;
import Gadgets.Type.Type;
import Syntax.MangoBaseVisitor;
import Syntax.MangoParser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import static Gadgets.Name.getName;
import static Gadgets.TypeParser.parseType;

/**
 * This class is intended to fully build up an AST from the parsetree generated by ANTLR v4.
 * <p>
 * Created by Ficos on 16/4/2.
 */
public class ASTBuilder extends MangoBaseVisitor<AST> {
    private SymbolTable global = new SymbolTable();
    private String nowClass = null;
    private Stack<LoopScope> nowLoop = new Stack<>();
    private FuncDecl nowFunc = null;
    private Boolean finelyReturned = false;

    private Boolean suit(Type base, Type rhs) {
        return rhs.isSuitableAs(base);
    }


    public ASTBuilder(org.antlr.v4.runtime.tree.ParseTree ctx) {
        // collect information before visit.
        ClassCollector classCollector = new ClassCollector(global);
        Field_FunctionCollector field_functionCollector = new Field_FunctionCollector(global);

        ParseTreeWalker walker = new ParseTreeWalker();

        walker.walk(classCollector, ctx);
        walker.walk(field_functionCollector, ctx);

        if (!(classCollector.isAllCorrect() &&
                field_functionCollector.isAllCorrect()))
            throw new SemanticError();
    }

    @Override
    public AST visitProg(MangoParser.ProgContext ctx) {
        List<Decl> decls = new LinkedList<>();
        for (ParserRuleContext child : ctx.decl()) {
            decls.add((Decl) visit(child));
        }
        return new Program(decls, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitVarDecl(MangoParser.VarDeclContext ctx) {
        Type varType;
        ExprStmt rhs = null;
        Name varName = getName(ctx.ID().getText());
        try {
            varType = parseType(ctx.type().getText(), global);
        } catch (Undefined err) {
            System.err.println("Used undefined class type" +
                    ctx.type().getText() + " at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        if (ctx.expr() != null) {
            rhs = (ExprStmt) visit(ctx.expr());
            if (!suit(varType, rhs.getType())) {
                System.err.println("Unsuitable type in variable declaration, expect " +
                        varType + " but get " + rhs.getType() + ", at line " + ctx.getStart().getLine());
                throw new SemanticError();
            }
        }
        VarSymbol varInfo = new VarSymbol(global.getCurrentScope(),
                varName,
                varType);
        try {
            global.define(varName, varInfo);
        } catch (Redefine err) {
            System.err.println("Redefined variable " + ctx.ID().getText() +
                    ", at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        // scopeID == 0 means it's now in global
        if (varInfo.getScopeID() == 0) {
            return new VarDecl(varInfo, rhs, new Position(ctx.getStart().getLine()));
        } else {
            return new VarDeclStmt(varInfo, rhs, new Position(ctx.getStart().getLine()));
        }
    }

//    @Override
//    public AST visitAtom(MangoParser.AtomContext ctx) {
//
//        return visitChildren(ctx);
//    }
//
//    @Override
//    public AST visitArrayType(MangoParser.ArrayTypeContext ctx) {
//        return visitChildren(ctx);
//    }
//
//    @Override
//    public AST visitAtomType(MangoParser.AtomTypeContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitFuncDecl(MangoParser.FuncDeclContext ctx) {
        Name funcName;
        if (nowClass != null) {
            funcName = Name.getName(nowClass + '.' + ctx.ID().getText());
        } else funcName = Name.getName(ctx.ID().getText());

        FuncSymbol funcInfo;
        try {
            funcInfo = (FuncSymbol) global.resolve(funcName);
        } catch (Undefined err) {
            throw new Bug_FuncNotDefine();
        }

        global.beginScope();
        if (funcInfo.getFormalParametersType() != null) {
            ListIterator<Type> APTitr = funcInfo.getFormalParametersType().listIterator();
            ListIterator<Name> APNitr = funcInfo.getFormalParametersName().listIterator();

            Name varName = null;
            try {
                while (APTitr.hasNext()) {
                    varName = APNitr.next();
                    global.define(varName, new VarSymbol(global.getCurrentScope(),
                            varName, APTitr.next()));
                }
            } catch (Redefine err) {
                System.err.println("Redefined variable " + varName +
                        " at line " + ctx.getStart().getLine());
                throw new SemanticError();
            }
        }
        FuncDecl func = new FuncDecl(funcInfo, null, new Position(ctx.getStart().getLine()));


        nowFunc = func;
        finelyReturned = false;

        CompoundStmt block = (CompoundStmt) visit(ctx.block());

        if (funcInfo.getReturnType() != null && !finelyReturned) {
            System.err.println("Function return not found, expecting return type " + funcInfo.getReturnType() + ", at " + func.getPosition());
            throw new SemanticError();
        }
        global.endScope();
        nowFunc = null;


        func.fillBlock(block);
        return func;
    }

//    @Override public AST visitFormalParameterList(MangoParser.FormalParameterListContext ctx) { return null; }
//
//    @Override public AST visitFormalParameter(MangoParser.FormalParameterContext ctx) { return null; }


    @Override
    public AST visitBlock(MangoParser.BlockContext ctx) {
        List<Stmt> stmts = new LinkedList<>();
        global.beginScope();
        for (MangoParser.StmtContext s : ctx.stmt()) {
            Stmt temp = (Stmt) visit(s);
            // if it is an empty statement
            if (temp == null) continue;
            stmts.add(temp);
        }
        global.endScope();
        return new CompoundStmt(stmts, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitEmptyStmt(MangoParser.EmptyStmtContext ctx) {
        return null;
    }

//    @Override
//    public AST visitExprStmt(MangoParser.ExprStmtContext ctx) {
//        return visitChildren(ctx);
//    }

//    @Override
//    public AST visitCompoundStmt(MangoParser.CompoundStmtContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitSelectionStmt(MangoParser.SelectionStmtContext ctx) {
        MangoParser.SelectionContext info = ctx.selection();
        ExprStmt condition = (ExprStmt) visit(info.expr());

        finelyReturned = false;
        Stmt then = (Stmt) visit(info.stmt(0));

        List<ExprStmt> subSelectionConditions = new LinkedList<>();
        List<Stmt> subSelectionThenStmts = new LinkedList<>();

        List<MangoParser.SubSelectionContext> elseif = info.subSelection();
        ListIterator<MangoParser.SubSelectionContext> elseifItr = elseif.listIterator();

        MangoParser.SubSelectionContext tempElseIf;
        while (elseifItr.hasNext()) {
            tempElseIf = elseifItr.next();
            finelyReturned = false;
            subSelectionConditions.add((ExprStmt) visit(tempElseIf.expr()));
            subSelectionThenStmts.add((Stmt) visit(tempElseIf.stmt()));
        }

        Stmt elseStmt = null;
        // if there is a else expression at the end
        if (info.stmt().size() > 1) {
            finelyReturned = false;
            elseStmt = (Stmt) visit(info.stmt(1));
        }

        return new SelectionStmt(condition, then,
                subSelectionConditions, subSelectionThenStmts,
                elseStmt, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitIterationStmt(MangoParser.IterationStmtContext ctx) {
//        return visitChildren(ctx);
//    }

//    @Override
//    public AST visitJumpStmt(MangoParser.JumpStmtContext ctx) {
//        return visitChildren(ctx);
//    }

//    @Override
//    public AST visitVarDeclStmt(MangoParser.VarDeclStmtContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitReturnStmt(MangoParser.ReturnStmtContext ctx) {
        ExprStmt returnExpr = null;
        if (ctx.expr() != null) {
            returnExpr = (ExprStmt) visit(ctx.expr());
        }
        // Checking whether the return type is suitable
        if (returnExpr == null) {
            if (nowFunc.getFuncInfo().getReturnType() != null) {
                System.err.println("a non-\"void\" function expecting return of type " + nowFunc.getFuncInfo().getReturnType() +
                        ", but found a pure return, at line " + ctx.getStart().getLine());
                throw new SemanticError();
            }
        } else if (returnExpr.getType() == null) {
            if (nowFunc.getFuncInfo().getReturnType() == null) {
                System.err.println("a \"void\" function , but found a    \"null\"   return, at line " + ctx.getStart().getLine());
                throw new SemanticError();
            } else {
                if (!((nowFunc.getFuncInfo().getReturnType() instanceof ArrayType) ||
                        (nowFunc.getFuncInfo().getReturnType() instanceof ClassType))) {
                    System.err.println("Improper function return, expecting return of type " +
                            nowFunc.getFuncInfo().getReturnType() +
                            ", but found a return of null, at line " + ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
        } else {
            if (nowFunc.getFuncInfo().getReturnType() == null) {
                System.err.println("\"void\" function, but found a return of type " + returnExpr.getType() +
                        ", at line " + ctx.getStart().getLine());
                throw new SemanticError();
            } else {
                if (!returnExpr.getType().isSuitableAs(nowFunc.getFuncInfo().getReturnType())) {
                    System.err.println("Improper function return, expecting type " +
                            nowFunc.getFuncInfo().getReturnType() +
                            ", but found a return of type " + returnExpr.getType() + ", at line " + ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
        }
        finelyReturned = true;
        return new ReturnStmt(returnExpr, nowFunc, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitBreakStmt(MangoParser.BreakStmtContext ctx) {
        if (nowLoop.isEmpty()) {
            System.err.println("Unexpected break statement, at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new BreakStmt(nowLoop.peek(), new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitContinueStmt(MangoParser.ContinueStmtContext ctx) {
        if (nowLoop.isEmpty()) {
            System.err.println("Unexpected continue statement, at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new ContinueStmt(nowLoop.peek(), new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitSelection(MangoParser.SelectionContext ctx) {
//        return visitChildren(ctx);
//    }
//
//    @Override
//    public AST visitSubSelection(MangoParser.SubSelectionContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitWhileLoop(MangoParser.WhileLoopContext ctx) {
        ExprStmt condition = (ExprStmt) visit(ctx.expr());
        if (!condition.getType().isSuitableAs(SymbolTable.BOOL)) {
            System.err.println("False type " + condition.getType() + ", expecting bool type, at " + condition.getPosition());
            throw new SemanticError();
        }
        WhileStmt whileLoop = new WhileStmt(condition, null, new Position(ctx.getStart().getLine()));

        nowLoop.push(whileLoop);
        Stmt loop = (Stmt) visit(ctx.stmt());
        nowLoop.pop();


        whileLoop.fillLoop(loop);
        return whileLoop;
    }

    @Override
    public AST visitForLoop(MangoParser.ForLoopContext ctx) {
        ExprStmt init = (ExprStmt) visit(ctx.init);
        ExprStmt condition = (ExprStmt) visit(ctx.condition);
        if (!condition.getType().isSuitableAs(SymbolTable.BOOL)) {
            System.err.println("False type " + condition.getType() + ", expecting bool type, at " + condition.getPosition());
            throw new SemanticError();
        }
        ExprStmt after = (ExprStmt) visit(ctx.after);
        ForStmt forLoop = new ForStmt(init, condition, after, null, new Position(ctx.getStart().getLine()));

        nowLoop.push(forLoop);
        Stmt loop = (Stmt) visit(ctx.stmt());
        nowLoop.pop();

        forLoop.fillLoop(loop);
        return forLoop;
    }

//    @Override
//    public AST visitBracket(MangoParser.BracketContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitCall(MangoParser.CallContext ctx) {
        FuncSymbol funcInfo;
        try {
            if (nowClass != null) {
                try {
                    funcInfo = (FuncSymbol) global.resolve(getName(nowClass + '.' + ctx.ID().getText()));
                } catch (Undefined notClassFunction) {
                    Symbol test = global.resolve(getName(ctx.ID().getText()));
                    if (!(test instanceof FuncSymbol)) throw new Undefined();
                    else funcInfo = (FuncSymbol) test;
                }
            } else {
                funcInfo = (FuncSymbol) global.resolve(getName(ctx.ID().getText()));
            }
        } catch (Undefined err) {
            System.err.println("Used undefined function" +
                    ctx.ID().getText() + " at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }

        // if the actual function call have no parameters
        // note that exprList might be null
        if (ctx.exprList() == null) {
            // P n, A n
            if (funcInfo.getFormalParametersName() == null) {
                return new CallExpr(funcInfo, null, new Position(ctx.getStart().getLine()));
            }
            // P nn, A n,Fault
            else {
                System.err.println("Wrong function call at line " + ctx.getStart().getLine() +
                        ", see function declaration at " + funcInfo);
                throw new SemanticError();
            }
        }
        // P n, A nn, fault
        if (funcInfo.getFormalParametersName() == null && ctx.exprList() != null) {
            System.err.println("Wrong function call at line " + ctx.getStart().getLine() +
                    ", see function declaration at " + funcInfo);
            throw new SemanticError();
        }
        // check P nn, A nn
        if (ctx.exprList().expr().size() != funcInfo.getFormalParametersName().size()) {
            System.err.println("Function call parameter mismatch at line " + ctx.getStart().getLine() +
                    ", see function declaration at " + funcInfo);
            throw new SemanticError();
        }
        // compare AP and FP
        List<MangoParser.ExprContext> APc = ctx.exprList().expr();
        List<Type> APT = new LinkedList<>();
        List<ExprStmt> AP = new LinkedList<>();
        ListIterator<MangoParser.ExprContext> APcItr = APc.listIterator(0);
        ListIterator<ExprStmt> APItr = AP.listIterator(0);
        while (APItr.hasNext()) {
            APItr.add((ExprStmt) visit(APcItr.next()));
            APT.add(APItr.previous().getType());
        }
        if (!funcInfo.isValidParameters(APT)) {
            System.err.println("Function call parameter mismatch at line " + ctx.getStart().getLine() +
                    ", see function declaration at " + funcInfo);
            throw new SemanticError();
        }

        return new CallExpr(funcInfo, AP, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitCreation(MangoParser.CreationContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitSelfOpPost(MangoParser.SelfOpPostContext ctx) {
        ExprStmt lv = (ExprStmt) visit(ctx.expr());
        if (!(lv instanceof LValue)) {
            System.out.println("Wrong operation on non-lvalue " +
                    ctx.expr().getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new SelfOpPostExpr(lv, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitIDLeaf(MangoParser.IDLeafContext ctx) {
        VarSymbol varInfo;
        try {
            if (nowClass != null) {
                try {
                    varInfo = (VarSymbol) global.resolve(getName(nowClass + '.' + ctx.ID().getText()));
                } catch (Undefined notClassField) {
                    // try resolve it in the outer scope
                    Symbol test = global.resolve(getName(ctx.ID().getText()));
                    if (!(test instanceof VarSymbol)) throw new Undefined();
                    else varInfo = (VarSymbol) test;
                }
            } else {
                varInfo = (VarSymbol) global.resolve(getName(ctx.ID().getText()));
            }
        } catch (Undefined err) {
            System.err.println("Used undefined variable" +
                    ctx.ID().getText() + " at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new VarExpr(varInfo, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitIndex(MangoParser.IndexContext ctx) {
        ExprStmt base = (ExprStmt) visit(ctx.expr(0));
        if (!(base.getType() instanceof ArrayType)) {
            System.out.println("Wrong indexing " +
                    ctx.getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        ExprStmt index = (ExprStmt) visit(ctx.expr(1));
        if (!(index.getType().isSuitableAs(SymbolTable.INT))) {
            System.out.println("Wrong indexing " +
                    ctx.getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new IndexExpr(base, index, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitLogNot(MangoParser.LogNotContext ctx) {
        ExprStmt context = (ExprStmt) visit(ctx.expr());
        if (!context.getType().isSuitableAs(SymbolTable.BOOL)) {
            System.out.println("Wrong Logical Not Expression " +
                    ctx.getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new LogNotExpr(context, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitConstantLeaf(MangoParser.ConstantLeafContext ctx) {
//        return visitChildren(ctx);
//    }


    @Override
    public AST visitConstant(MangoParser.ConstantContext ctx) {
        if (ctx.BOOL() != null) {
            return new BoolExpr(ctx.getText(), new Position(ctx.getStart().getLine()));
        } else if (ctx.STRING() != null) {
            return new StringExpr(ctx.getText(), new Position(ctx.getStart().getLine()));
        } else if (ctx.INT() != null) {
            return new IntExpr(ctx.getText(), new Position(ctx.getStart().getLine()));
        } else if (ctx.NULL() != null) {
            return new NullExpr(new Position(ctx.getStart().getLine()));
        } else throw new Bug_TextError();
    }

    @Override
    public AST visitSelfOpPre(MangoParser.SelfOpPreContext ctx) {
        ExprStmt lv = (ExprStmt) visit(ctx.expr());
        if (!(lv instanceof LValue)) {
            System.out.println("Wrong operation on non-lvalue " +
                    ctx.expr().getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new SelfOpPreExpr(lv, new Position(ctx.getStart().getLine()));

    }

    @Override
    public AST visitLogBinary(MangoParser.LogBinaryContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr(0));
        ExprStmt rhs = (ExprStmt) visit(ctx.expr(1));
        LogBinaryOp op = null;
        switch (ctx.op.getType()) {
            case MangoParser.LESS:
                op = LogBinaryOp.LESS;
                break;
            case MangoParser.LARGE:
                op = LogBinaryOp.LARGE;
                break;
            case MangoParser.LEQ:
                op = LogBinaryOp.LEQ;
                break;
            case MangoParser.GEQ:
                op = LogBinaryOp.GEQ;
                break;
            case MangoParser.EQ:
                op = LogBinaryOp.EQ;
                break;
            case MangoParser.NEQ:
                op = LogBinaryOp.NEQ;
                break;
            case MangoParser.LOG_AND:
                op = LogBinaryOp.LOG_AND;
                break;
            case MangoParser.LOG_OR:
                op = LogBinaryOp.LOG_OR;
                break;
        }
        switch (ctx.op.getType()) {
            case MangoParser.LARGE:
            case MangoParser.LEQ:
            case MangoParser.GEQ:
            case MangoParser.NEQ: {
                if (!(lhs.getType().isSuitableAs(SymbolTable.INT) &&
                        rhs.getType().isSuitableAs(SymbolTable.INT))) {
                    System.out.println("Logical operation on wrong operands " +
                            ctx.getText() + ", at line " +
                            ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
            break;
            case MangoParser.EQ:
            case MangoParser.LESS: {
                if (!(lhs.getType().isSuitableAs(SymbolTable.INT) &&
                        rhs.getType().isSuitableAs(SymbolTable.INT)) &&
                        !(lhs.getType().isSuitableAs(SymbolTable.STRING) &&
                                rhs.getType().isSuitableAs(SymbolTable.STRING))) {
                    System.out.println("Logical operation on wrong operands " +
                            ctx.getText() + ", at line " +
                            ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
            break;
            case MangoParser.LOG_AND:
            case MangoParser.LOG_OR: {
                if (!(lhs.getType().isSuitableAs(SymbolTable.BOOL) &&
                        rhs.getType().isSuitableAs(SymbolTable.BOOL))) {
                    System.out.println("Logical operation on wrong operands " +
                            ctx.getText() + ", at line " +
                            ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
        }
        return new LogBinaryExpr(lhs, op, rhs, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitBinary(MangoParser.BinaryContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr(0));
        ExprStmt rhs = (ExprStmt) visit(ctx.expr(1));
        BinaryOp op = null;
        switch (ctx.op.getType()) {
            case MangoParser.MULT:
                op = BinaryOp.MULT;
                break;
            case MangoParser.DIV:
                op = BinaryOp.DIV;
                break;
            case MangoParser.MOD:
                op = BinaryOp.MOD;
                break;
            case MangoParser.PLUS:
                op = BinaryOp.PLUS;
                break;
            case MangoParser.MINUS:
                op = BinaryOp.MINUS;
                break;
            case MangoParser.SHIFT_L:
                op = BinaryOp.SHIFT_L;
                break;
            case MangoParser.SHIFT_R:
                op = BinaryOp.SHIFT_R;
                break;
            case MangoParser.BIT_AND:
                op = BinaryOp.BIT_AND;
                break;
            case MangoParser.BIT_XOR:
                op = BinaryOp.BIT_XOR;
                break;
            case MangoParser.BIT_OR:
                op = BinaryOp.BIT_OR;
                break;
        }
        switch (ctx.op.getType()) {
            case MangoParser.MULT:
            case MangoParser.DIV:
            case MangoParser.MOD:
            case MangoParser.MINUS:
            case MangoParser.SHIFT_L:
            case MangoParser.SHIFT_R:
            case MangoParser.BIT_AND:
            case MangoParser.BIT_XOR:
            case MangoParser.BIT_OR: {
                if (!(lhs.getType().isSuitableAs(SymbolTable.INT) &&
                        rhs.getType().isSuitableAs(SymbolTable.INT))) {
                    System.out.println("operation on wrong operands " +
                            ctx.getText() + ", at line " +
                            ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
            break;
            case MangoParser.PLUS: {
                if (!(lhs.getType().isSuitableAs(SymbolTable.INT) &&
                        rhs.getType().isSuitableAs(SymbolTable.INT)) &&
                        !(lhs.getType().isSuitableAs(SymbolTable.STRING) &&
                                rhs.getType().isSuitableAs(SymbolTable.STRING))) {
                    System.out.println("operation on wrong operands " +
                            ctx.getText() + ", at line " +
                            ctx.getStart().getLine());
                    throw new SemanticError();
                }
            }
        }
        return new BinaryExpr(lhs, op, rhs, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitSign(MangoParser.SignContext ctx) {
        ExprStmt base = (ExprStmt) visit(ctx.expr());
        if (!base.getType().isSuitableAs(SymbolTable.INT)) {
            System.out.println("Wrong sign operation " +
                    ctx.expr().getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new SignExpr(base, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitAssign(MangoParser.AssignContext ctx) {
        ExprStmt lv = (ExprStmt) visit(ctx.expr(0));
        if (!(lv instanceof LValue)) {
            System.out.println("Wrong assignment operation on non-Lvalue" +
                    ctx.getText() + ", at line " +
                    ctx.getStart().getLine());
            throw new SemanticError();
        }
        ExprStmt rhs = (ExprStmt) visit(ctx.expr(1));
        return new AssignExpr(lv, rhs, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitBitNot(MangoParser.BitNotContext ctx) {
        ExprStmt context = (ExprStmt) visit(ctx.expr());
        if (!context.getType().isSuitableAs(SymbolTable.INT)) {
            System.err.println("Invalid operation operand " + ctx.getText() + ", at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return visitChildren(ctx);
    }

    @Override
    public AST visitFieldAccess(MangoParser.FieldAccessContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr());
        if (!(lhs.getType() instanceof ClassType)) {
            System.err.println("Wrong class Field Access at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        Name func = getName(lhs.getType().toString() +
                '.' + ctx.ID().getText());
        FuncSymbol funcInfo;
        try {
            funcInfo = (FuncSymbol) global.resolve(func);
        } catch (Undefined err) {
            System.err.println("Used class function " + ctx.getText() + ", at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new ClassFuncAccessExpr(lhs, funcInfo, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitClassFuncAccess(MangoParser.ClassFuncAccessContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr());
        if (!(lhs.getType() instanceof ClassType)) {
            System.err.println("Wrong class Field Access at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        Name func = getName(lhs.getType() + "." + ctx.ID().getText());
        FuncSymbol funcInfo = null;
        try {
            funcInfo = (FuncSymbol) global.resolve(func);
        } catch (Undefined err) {
            System.err.println("Used undefined class function   " + func + "    , at line " + ctx.getStart().getLine());
        }
        return new ClassFuncAccessExpr(lhs, funcInfo, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitArrayCreate(MangoParser.ArrayCreateContext ctx) {
        ArrayType base;
        try {
            base = (ArrayType) parseType(ctx.getText().substring(3), global);
        } catch (Undefined err) {
            System.err.println("Using undefined type to create new variable at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        ExprStmt index = (ExprStmt) visit(ctx.expr());
        if (!index.getType().isSuitableAs(SymbolTable.INT)) {
            System.err.println("Unexpected index" + ctx.expr().getText() + " at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new ArrayCreationExpr(base, (IntExpr) index, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitAtomCreate(MangoParser.AtomCreateContext ctx) {
        Type base;
        try {
            base = global.lookUpType(ctx.atom().getText());
        } catch (Undefined err) {
            System.err.println("Using undefined type to create new variable at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new AtomCreationExpr(base, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitExprList(MangoParser.ExprListContext ctx) {
//
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitClassDecl(MangoParser.ClassDeclContext ctx) {
        nowClass = ctx.ID().getText();
        List<VarDecl> variables = null;
        List<FuncDecl> functions = null;

        List<MangoParser.MemberDeclContext> decls = ctx.classBlock().memberDecl();
        ListIterator<MangoParser.MemberDeclContext> declsItr = decls.listIterator();

        while (declsItr.hasNext()) {
            Decl temp = (Decl) visit(declsItr.next());
            if (temp instanceof VarDecl) {
                if (variables == null) variables = new LinkedList<>();
                variables.add((VarDecl) temp);
            } else if (temp instanceof FuncDecl) {
                if (functions == null) functions = new LinkedList<>();
                functions.add((FuncDecl) temp);
            } else throw new Bug_WrongReturn();
        }
        ClassDecl classDecl;
        try {
            classDecl = new ClassDecl(variables, functions,
                    (ClassType) global.lookUpType(nowClass), new Position(ctx.getStart().getLine()));
        } catch (Undefined err) {
            throw new Bug_TextError();
        }
        nowClass = null;
        return classDecl;
    }

//    @Override
//    public AST visitClassBlock(MangoParser.ClassBlockContext ctx) {
//        return visitChildren(ctx);
//    }


    // remember to return a VarDecl
    @Override
    public AST visitClassField(MangoParser.ClassFieldContext ctx) {
        VarSymbol classVar;
        try {
            classVar = (VarSymbol) global.resolve(getName(nowClass + '.' + ctx.ID().getText()));
        } catch (Undefined err) {
            throw new Bug_TextError();
        }
        return new VarDecl(classVar, null, new Position(ctx.getStart().getLine()));
    }


//    @Override
//    public AST visitClassFunction(MangoParser.ClassFunctionContext ctx) {
//        return visitChildren(ctx);
//    }

}