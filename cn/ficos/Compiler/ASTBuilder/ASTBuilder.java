package cn.ficos.Compiler.ASTBuilder;

import cn.ficos.Compiler.AST.*;
import cn.ficos.Compiler.Exceptions.*;
import cn.ficos.Compiler.Gadgets.*;
import cn.ficos.Compiler.Gadgets.Symbol.FuncSymbol;
import cn.ficos.Compiler.Gadgets.Symbol.Symbol;
import cn.ficos.Compiler.Gadgets.Symbol.VarSymbol;
import cn.ficos.Compiler.Gadgets.Type.ArrayType;
import cn.ficos.Compiler.Gadgets.Type.ClassType;
import cn.ficos.Compiler.Gadgets.Type.Type;
import cn.ficos.Compiler.Syntax.MangoBaseVisitor;
import cn.ficos.Compiler.Syntax.MangoParser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import static cn.ficos.Compiler.Gadgets.Name.getName;
import static cn.ficos.Compiler.Gadgets.TypeParser.parseType;

/**
 * This class is intended to fully build up an AST from the parsetree generated by ANTLR v4.
 * <p> node that ClassFuncAccess also represents the BuiltInType
 * Created by Ficos on 16/4/2.
 */
public class ASTBuilder extends MangoBaseVisitor<AST> {
    private SymbolTable global = new SymbolTable();
    private String nowClass = null;
    private Stack<LoopScope> nowLoop = new Stack<>();
    private FuncDecl nowFunc = null;


    public ASTBuilder(org.antlr.v4.runtime.tree.ParseTree ctx) {
        // collect information before visit.
        ClassCollector classCollector = new ClassCollector(global);
        Field_FunctionCollector field_functionCollector = new Field_FunctionCollector(global);

        ParseTreeWalker walker = new ParseTreeWalker();

        walker.walk(classCollector, ctx);
        if (!classCollector.isAllCorrect()) throw new SemanticError();
        walker.walk(field_functionCollector, ctx);
        if (!field_functionCollector.isAllCorrect()) throw new SemanticError();
    }

    private Boolean suit(Type base, Type rhs) {
        if (rhs == null) {
            return (base instanceof ArrayType || base instanceof ClassType);
        }
        return rhs.isSuitableAs(base);
    }

    @Override
    public AST visitProg(MangoParser.ProgContext ctx) {
        List<Decl> decls = new LinkedList<>();
        for (ParserRuleContext child : ctx.decl()) {
            decls.add((Decl) visit(child));
        }
        return new Program(decls, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitVarDecl(MangoParser.VarDeclContext ctx) {
        ExprStmt rhs = null;
//        The creation should be visit first, e.g. int a = a + 1;
        if (ctx.expr() != null) {
            rhs = (ExprStmt) visit(ctx.expr());
        }

        Type varType;
        Name varName = getName(ctx.ID().getText());
        try {
            varType = parseType(ctx.type().getText(), global);
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined class type <" +
                    ctx.type().getText() + '>');
            throw new SemanticError();
        }

        if (ctx.expr() != null && !suit(varType, rhs.getType())) {
            System.err.println("line " + ctx.getStart().getLine() + ": Unsuitable type in variable declaration, expect <" +
                    varType + "> but meet <" + rhs.getType() + ">");
            throw new SemanticError();
        }

        VarSymbol varInfo;
        if (global.getCurrentScope() == 0) {
            varInfo = new VarSymbol(varName, varType, VarSymbol.global);
        } else {
            varInfo = new VarSymbol(varName, varType, VarSymbol.local);
        }
        try {
            global.define(varName, varInfo);
        } catch (Redefine err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Redefining variable <" + ctx.ID().getText() +
                    ">");
            throw new SemanticError();
        }

        // currentScope == 0 means it's now in global
        if (global.getCurrentScope() == 0) {
            return new VarDecl(varInfo, rhs, new Position(ctx.getStart().getLine()));
        } else {
            return new VarDeclStmt(varInfo, rhs, new Position(ctx.getStart().getLine()));
        }
    }

//    @Override
//    public AST visitAtom(MangoParser.AtomContext ctx) {
//
//        return visitChildren(ctx);
//    }
//
//    @Override
//    public AST visitArrayType(MangoParser.ArrayTypeContext ctx) {
//        return visitChildren(ctx);
//    }
//
//    @Override
//    public AST visitAtomType(MangoParser.AtomTypeContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitFuncDecl(MangoParser.FuncDeclContext ctx) {
        Name funcName;
        if (nowClass != null) {
            funcName = Name.getName(nowClass + '.' + ctx.ID().getText());
        } else funcName = Name.getName(ctx.ID().getText());

        FuncSymbol funcInfo;
        try {
            funcInfo = (FuncSymbol) global.resolve(funcName);
        } catch (Undefined err) {
            throw new Bug_FuncNotDefine();
        }


        if (funcName.toString().equals("main")) {
            if (funcInfo.getReturnType() != SymbolTable.INT) {
                System.err.println("line " + ctx.getStart().getLine() + ": Wrong main function return type");
                throw new SemanticError();
            }
            if (funcInfo.getFormalParametersName() != null) {
                System.err.println("line " + ctx.getStart().getLine() + ": Main function should not have any formal parameters");
                throw new SemanticError();
            }
        }
        global.beginScope();
        if (funcInfo.getFormalParametersType() != null) {
            ListIterator<Type> APTitr = funcInfo.getFormalParametersType().listIterator();
            ListIterator<Name> APNitr = funcInfo.getFormalParametersName().listIterator();

            Name varName = null;
            try {
                int count = 0;
                while (APTitr.hasNext()) {
                    ++count;
                    varName = APNitr.next();
                    VarSymbol temp;
                    if (count <= 4) {
                        temp = new VarSymbol(varName, APTitr.next(), VarSymbol.local);
                    } else {
                        temp = new VarSymbol(varName, APTitr.next(), VarSymbol.parameter);
                    }
                    funcInfo.getParameter().add(temp);
                    global.define(varName, temp);
                }
            } catch (Redefine err) {
                System.err.println("line " + ctx.getStart().getLine() + ": Redefined variable <" + varName +
                        ">");
                throw new SemanticError();
            }
        }
        FuncDecl func = new FuncDecl(funcInfo, null, new Position(ctx.getStart().getLine()));


        nowFunc = func;
//        finelyReturned = false;
        List<Stmt> stmts = null;
        if (ctx.block().stmt() != null) {
            stmts = new LinkedList<>();
            for (MangoParser.StmtContext s : ctx.block().stmt()) {
                Stmt temp = (Stmt) visit(s);
                // if it is an empty statement
                if (temp == null) continue;
                stmts.add(temp);
            }
        }


//        if (funcInfo.getReturnType() != null && !finelyReturned && !(funcInfo.getReturnType() == SymbolTable.INT && funcName.toString().equals("main"))) {
//            System.err.println("line " + ctx.getStart().getLine() + ": Function return not found, expecting return type <" + funcInfo.getReturnType() + ">");
//            throw new SemanticError();
//        }
        global.endScope();
        nowFunc = null;


        func.fillStmts(stmts);
        return func;
    }

//    @Override public AST visitFormalParameterList(MangoParser.FormalParameterListContext ctx) { return null; }
//
//    @Override public AST visitFormalParameter(MangoParser.FormalParameterContext ctx) { return null; }


    @Override
    public AST visitBlock(MangoParser.BlockContext ctx) {
        List<Stmt> stmts = null;
        if (ctx.stmt() != null) {
            stmts = new LinkedList<>();
            global.beginScope();
            for (MangoParser.StmtContext s : ctx.stmt()) {
                Stmt temp = (Stmt) visit(s);
                // if it is an empty statement
                if (temp == null) continue;
                stmts.add(temp);
            }
        }
        global.endScope();
        return new CompoundStmt(stmts, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitEmptyStmt(MangoParser.EmptyStmtContext ctx) {
        return null;
    }

    @Override
    public AST visitExprStmt(MangoParser.ExprStmtContext ctx) {
        return visit(ctx.expr());
    }

//    @Override
//    public AST visitCompoundStmt(MangoParser.CompoundStmtContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitSelectionStmt(MangoParser.SelectionStmtContext ctx) {
        MangoParser.SelectionContext info = ctx.selection();
        ExprStmt condition = (ExprStmt) visit(info.expr());

        if (!suit(condition.getType(), SymbolTable.BOOL)) {
            System.err.println("line " + ctx.getStart().getLine() + ": False if condition of type <" + condition.getType() + ">, expecting bool type");
            throw new SemanticError();
        }
//        finelyReturned = false;
        Stmt then;
        if (info.stmt(0) instanceof MangoParser.CompoundStmtContext)
            then = (Stmt) visit(info.stmt(0));
        else {
            global.beginScope();
            then = (Stmt) visit(info.stmt(0));
            global.endScope();
        }

        List<ExprStmt> subSelectionConditions = new LinkedList<>();
        List<Stmt> subSelectionThenStmts = new LinkedList<>();

        List<MangoParser.SubSelectionContext> elseif = info.subSelection();
        ListIterator<MangoParser.SubSelectionContext> elseifItr = elseif.listIterator();

        MangoParser.SubSelectionContext tempElseIf;
        while (elseifItr.hasNext()) {
            tempElseIf = elseifItr.next();
//            finelyReturned = false;
            ExprStmt elseIfCondition = (ExprStmt) visit(tempElseIf.expr());
            if (!suit(condition.getType(), SymbolTable.BOOL)) {
                System.err.println("line " + tempElseIf.getStart().getLine() + ": False else-if condition of type <" + elseIfCondition.getType() + ">, expecting bool type");
                throw new SemanticError();
            }
            subSelectionConditions.add(elseIfCondition);
            if (tempElseIf.stmt() instanceof MangoParser.CompoundStmtContext)
                subSelectionThenStmts.add((Stmt) visit(tempElseIf.stmt()));
            else {
                global.beginScope();
                subSelectionThenStmts.add((Stmt) visit(tempElseIf.stmt()));
                global.endScope();
            }
        }

        Stmt elseStmt = null;
        // if there is a else expression at the end
        if (info.stmt().size() > 1) {
//            finelyReturned = false;
            if (info.stmt(1) instanceof MangoParser.CompoundStmtContext)
                elseStmt = (Stmt) visit(info.stmt(1));
            else {
                global.beginScope();
                elseStmt = (Stmt) visit(info.stmt(1));
                global.endScope();
            }
        }

        return new SelectionStmt(condition, then,
                subSelectionConditions, subSelectionThenStmts,
                elseStmt, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitIterationStmt(MangoParser.IterationStmtContext ctx) {
//        return visitChildren(ctx);
//    }

//    @Override
//    public AST visitJumpStmt(MangoParser.JumpStmtContext ctx) {
//        return visitChildren(ctx);
//    }

//    @Override
//    public AST visitVarDeclStmt(MangoParser.VarDeclStmtContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitReturnStmt(MangoParser.ReturnStmtContext ctx) {
        ExprStmt returnExpr = null;
        if (ctx.expr() != null) {
            returnExpr = (ExprStmt) visit(ctx.expr());
        }
        // Checking whether the return type is suitable
        if (returnExpr == null) {
            if (nowFunc.getFuncInfo().getReturnType() != null) {
                System.err.println("line " + ctx.getStart().getLine() + ": Not-void function <" + nowFunc.getFuncInfo().getName() + "> expecting a return of type <" + nowFunc.getFuncInfo().getReturnType() +
                        ">, but found a pure return");
                throw new SemanticError();
            }
        } else if (returnExpr.getType() == null) {
            if (nowFunc.getFuncInfo().getReturnType() == null) {
                System.err.println("line " + ctx.getStart().getLine() + ": <void> function <" + nowFunc.getFuncInfo().getName() + "> found a <null> return");
                throw new SemanticError();
            } else {
                if (!((nowFunc.getFuncInfo().getReturnType() instanceof ArrayType) ||
                        (nowFunc.getFuncInfo().getReturnType() instanceof ClassType))) {
                    System.err.println("line " + ctx.getStart().getLine() + ": Improper function return, expecting a return of type <" +
                            nowFunc.getFuncInfo().getReturnType() +
                            ">, but found a return of <null>");
                    throw new SemanticError();
                }
            }
        } else {
            if (nowFunc.getFuncInfo().getReturnType() == null) {
                System.err.println("line " + ctx.getStart().getLine() + ": <void> function <" + nowFunc.getFuncInfo().getName() + "> found a return of type <" + returnExpr.getType() +
                        ">");
                throw new SemanticError();
            } else {
                if (!suit(nowFunc.getFuncInfo().getReturnType(), returnExpr.getType())) {
                    System.err.println("line " + ctx.getStart().getLine() + ": Improper function return, expecting type <" +
                            nowFunc.getFuncInfo().getReturnType() +
                            ">, but found a return of type <" + returnExpr.getType() + ">");
                    throw new SemanticError();
                }
            }
        }
//        finelyReturned = true;
        return new ReturnStmt(returnExpr, nowFunc, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitBreakStmt(MangoParser.BreakStmtContext ctx) {
        if (nowLoop.isEmpty()) {
            System.err.println("Unexpected break statement, at line " + ctx.getStart().getLine());
            throw new SemanticError();
        }
        return new BreakStmt(nowLoop.peek(), new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitContinueStmt(MangoParser.ContinueStmtContext ctx) {
        if (nowLoop.isEmpty()) {
            System.err.println("line " + ctx.getStart().getLine() + ": Unexpected <continue> statement");
            throw new SemanticError();
        }
        return new ContinueStmt(nowLoop.peek(), new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitSelection(MangoParser.SelectionContext ctx) {
//        return visitChildren(ctx);
//    }
//
//    @Override
//    public AST visitSubSelection(MangoParser.SubSelectionContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitWhileLoop(MangoParser.WhileLoopContext ctx) {
        ExprStmt condition = (ExprStmt) visit(ctx.expr());
        if (!suit(SymbolTable.BOOL, condition.getType())) {
            System.err.println("line " + ctx.getStart().getLine() + ": False while-loop condition of type <" + condition.getType() + ">, expecting bool type");
            throw new SemanticError();
        }
        WhileStmt whileLoop = new WhileStmt(condition, null, new Position(ctx.getStart().getLine()));


        // The following code intends to avoid
        // while(condition) int a = 1;
        // if in-while is not compound-statement, the declaration will occur in wrong scope
        nowLoop.push(whileLoop);
        Stmt loop;
        if (ctx.stmt() instanceof MangoParser.CompoundStmtContext)
            loop = (Stmt) visit(ctx.stmt());
        else {
            global.beginScope();
            loop = (Stmt) visit(ctx.stmt());
            global.endScope();
        }
        nowLoop.pop();


        whileLoop.fillLoop(loop);
        return whileLoop;
    }

    @Override
    public AST visitForLoop(MangoParser.ForLoopContext ctx) {
        ExprStmt init = null;
        if (ctx.init != null) {
            init = (ExprStmt) visit(ctx.init);
        }
        ExprStmt condition = null;
        if (ctx.condition != null) {
            condition = (ExprStmt) visit(ctx.condition);
            if (!suit(SymbolTable.BOOL, condition.getType())) {
                System.err.println("line " + ctx.getStart().getLine() + ": False for-loop condition of type <" + condition.getType() + ">, expecting bool type");
                throw new SemanticError();
            }
        }
        ExprStmt after = null;
        if (ctx.after != null) {
            after = (ExprStmt) visit(ctx.after);
        }
        ForStmt forLoop = new ForStmt(init, condition, after, null, new Position(ctx.getStart().getLine()));

        // The following code intends to avoid
        // for(conditions) int a = 1;
        // if in-for is not compound-statement, the declaration will occur in wrong scope
        nowLoop.push(forLoop);
        Stmt loop;
        if (ctx.stmt() instanceof MangoParser.CompoundStmtContext)
            loop = (Stmt) visit(ctx.stmt());
        else {
            global.beginScope();
            loop = (Stmt) visit(ctx.stmt());
            global.endScope();
        }
        nowLoop.pop();

        forLoop.fillLoop(loop);
        return forLoop;
    }

    @Override
    public AST visitBracket(MangoParser.BracketContext ctx) {
        return visit(ctx.expr());
    }

    @Override
    public AST visitCall(MangoParser.CallContext ctx) {
        FuncSymbol funcInfo;
        boolean inClassFunction = false;
        try {
            if (nowClass != null) {
                try {
                    funcInfo = (FuncSymbol) global.resolve(getName(nowClass + '.' + ctx.ID().getText()));
                    inClassFunction = true;
                } catch (Undefined notClassFunction) {
                    Symbol test = global.resolve(getName(ctx.ID().getText()));
                    if (!(test instanceof FuncSymbol)) throw new Undefined();
                    else funcInfo = (FuncSymbol) test;
                }
            } else {
                funcInfo = (FuncSymbol) global.resolve(getName(ctx.ID().getText()));
            }
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined function <" +
                    ctx.ID().getText() + ">");
            throw new SemanticError();
        } catch (java.lang.ClassCastException err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using variable <" + ctx.ID().getText() +
                    "> as a function");
            throw new SemanticError();
        }

        // if the actual function call have no parameters
        // note that exprList might be null
        if (ctx.exprList() == null) {
            // P n, A n
            if (funcInfo.getFormalParametersName() == null) {
                if (funcInfo.getReturnType() == null) {
                    return new CallExpr(funcInfo, null, new Position(ctx.getStart().getLine()), null);
                }
                return new CallExpr(funcInfo, null, new Position(ctx.getStart().getLine()));
            }
            // P nn, A n,Fault
            else if (!inClassFunction) {
                System.err.println("line " + ctx.getStart().getLine() + ": Wrong function call, see function declaration at <" + funcInfo.getName() + ">");
                throw new SemanticError();
            }
        }
        // P n, A nn, fault
        if (funcInfo.getFormalParametersName() == null && ctx.exprList() != null) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong function call, see function declaration at <" + funcInfo.getName() + ">");
            throw new SemanticError();
        }
        // check P nn, A nn
        if (!inClassFunction && ctx.exprList().expr().size() != funcInfo.getFormalParametersName().size()) {
            System.err.println("line " + ctx.getStart().getLine() + ": Function call parameter mismatching, see function declaration at <" + funcInfo + ">");
            throw new SemanticError();
        } else if (inClassFunction) {
            if ((ctx.exprList() == null && funcInfo.getFormalParametersName().size() != 1) ||
                    (ctx.exprList() != null && (ctx.exprList().expr().size() + 1) != funcInfo.getFormalParametersName().size())) {
                System.err.println("line " + ctx.getStart().getLine() + ": Function call parameter mismatching, see function declaration at <" + funcInfo + ">");
                throw new SemanticError();
            }
        }

        if (funcInfo.getName().toString().equals("_print") || funcInfo.getName().toString().equals("_println")) {
            ExprStmt temp = (ExprStmt) visit(ctx.exprList().expr(0));
            if (!suit(SymbolTable.STRING, temp.getType())) {
                System.err.println("line " + ctx.getStart().getLine() + ": Function call parameter mismatching, see function declaration at <" + funcInfo.getName() + ">");
                throw new SemanticError();
            }
//            if (temp instanceof CallExpr && ((CallExpr) temp).getFuncInfo().getName().toString().equals("_stringConcatenate")){


            List<Stmt> nowPrint = new LinkedList<>();
            parseStringConcatenation(nowPrint, temp);
            if (funcInfo.getName().toString().equals("_println")) {
                nowPrint.add(new CallExpr(SymbolTable.println,
                        Arrays.asList(new StringExpr("", new Position(ctx.getStart().getLine()))),
                        new Position(ctx.getStart().getLine()), null));
            }
            return new CompoundStmt(nowPrint, new Position(ctx.getStart().getLine()));


//            }
//            else {
//                LinkedList<ExprStmt> AP = new LinkedList<>();
//                AP.add(temp);
//                return new CallExpr(funcInfo, AP, new Position(ctx.getStart().getLine()), null);
//            }
        }

        LinkedList<Type> APT = new LinkedList<>();
        LinkedList<ExprStmt> AP = new LinkedList<>();
//        ListIterator<ExprStmt> APItr = AP.listIterator(0);
        if (inClassFunction && ctx.exprList() == null) {
            VarSymbol _this;
            try {
                _this = (VarSymbol) global.resolve(getName("this"));
                APT.add(_this.getType());
            } catch (Undefined e) {
                throw new Bug_TextError();
            }
            AP.addLast(new VarExpr(_this, new Position(ctx.getStart().getLine())));
        } else {
            List<MangoParser.ExprContext> APc = ctx.exprList().expr();
            ListIterator<MangoParser.ExprContext> APcItr = APc.listIterator(0);
            while (APcItr.hasNext()) {
                AP.addLast((ExprStmt) visit(APcItr.next()));
                APT.add(AP.getLast().getType());
            }
        }

        // compare AP and FP
        if (!funcInfo.isValidParameters(APT)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Function call parameter mismatching, see function declaration at <" + funcInfo.getName() + ">");
            throw new SemanticError();
        }

        if (funcInfo.getReturnType() == null) {
            return new CallExpr(funcInfo, AP, new Position(ctx.getStart().getLine()), null);
        }

        return new CallExpr(funcInfo, AP, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitCreation(MangoParser.CreationContext ctx) {
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitSelfOpPost(MangoParser.SelfOpPostContext ctx) {
        ExprStmt lv = (ExprStmt) visit(ctx.expr());
        if (!((lv instanceof LValue) && suit(SymbolTable.INT, lv.getType()))) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong operation on non-Lvalue <" +
                    ctx.expr().getText() + ">");
            throw new SemanticError();
        }
        Boolean op;
        if (ctx.op.getType() == MangoParser.PPLUS) op = true;
        else op = false;
        return new SelfOpPostExpr(op, lv, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitIDLeaf(MangoParser.IDLeafContext ctx) {
        VarSymbol varInfo;
        try {
            if (nowClass != null) {
                try {
                    varInfo = (VarSymbol) global.resolve(getName(nowClass + '.' + ctx.ID().getText()));
                    // automatically add an FieldAccessExpr
                    VarSymbol _this;
                    Name name = getName(ctx.ID().getText());
                    try {
                        _this = (VarSymbol) global.resolve(getName("this"));
                    } catch (Undefined e) {
                        throw new Bug_TextError();
                    }
                    return new FieldAccessExpr(varInfo.getType(),
                            new VarExpr(_this, new Position(ctx.getStart().getLine())),
                            name,
                            ((ClassType) _this.getType()).getShift(getName(nowClass + '.' + ctx.ID().getText())),
                            new Position(ctx.getStart().getLine()));
                } catch (Undefined notClassField) {
                    // try resolve it in the outer scope
                    Symbol test = global.resolve(getName(ctx.ID().getText()));
                    if (!(test instanceof VarSymbol)) throw new Undefined();
                    else varInfo = (VarSymbol) test;
                }
            } else {
                varInfo = (VarSymbol) global.resolve(getName(ctx.ID().getText()));
            }
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined variable <" +
                    ctx.ID().getText() + ">");
            throw new SemanticError();
        } catch (ClassCastException e) {
            System.out.println(ctx.getStart().getLine());
            throw e;
        }
        return new VarExpr(varInfo, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitIndex(MangoParser.IndexContext ctx) {
        ExprStmt base = (ExprStmt) visit(ctx.expr(0));
        if (!(base.getType() instanceof ArrayType)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong indexing <" + ctx.getText() + ">");
            throw new SemanticError();
        }
//        if (!(base instanceof LValue)) {
//            System.err.println("line " + ctx.getStart().getLine() + ": Wrong operation on non-Lvalue <" + ctx.getText() + ">");
//            throw new SemanticError();
//        }
        ExprStmt index = (ExprStmt) visit(ctx.expr(1));
        if (!(suit(SymbolTable.INT, index.getType()))) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong indexing <" + ctx.getText() + ">");
            throw new SemanticError();
        }

//        System.out.println("detected index on ");
//        System.out.print(base.getType());
//        System.out.print(((IntExpr)index).getValue());

        return new IndexExpr(base, index, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitLogNot(MangoParser.LogNotContext ctx) {
        ExprStmt context = (ExprStmt) visit(ctx.expr());
        if (!suit(SymbolTable.BOOL, context.getType())) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong Logical-Not Expression <" + ctx.getText() + ">");
            throw new SemanticError();
        }
        return new LogNotExpr(context, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitConstantLeaf(MangoParser.ConstantLeafContext ctx) {
        return visit(ctx.constant());
    }


    @Override
    public AST visitConstant(MangoParser.ConstantContext ctx) {
        if (ctx.BOOL() != null) {
            return new BoolExpr(ctx.getText(), new Position(ctx.getStart().getLine()));
        } else if (ctx.STRING() != null) {
            String temp = ctx.getText();
            temp = temp.substring(1, temp.lastIndexOf('"'));
            return new StringExpr(temp, new Position(ctx.getStart().getLine()));
        } else if (ctx.INT() != null) {
            return new IntExpr(ctx.getText(), new Position(ctx.getStart().getLine()));
        } else if (ctx.NULL() != null) {
            return new NullExpr(new Position(ctx.getStart().getLine()));
        } else throw new Bug_TextError();
    }

    @Override
    public AST visitSelfOpPre(MangoParser.SelfOpPreContext ctx) {
        ExprStmt lv = (ExprStmt) visit(ctx.expr());
        if (!((lv instanceof LValue) && suit(SymbolTable.INT, lv.getType()))) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong operation on non-Lvalue <" + ctx.expr().getText() + ">");
            throw new SemanticError();
        }
        Boolean op;
        if (ctx.op.getType() == MangoParser.PPLUS) op = true;
        else op = false;
        return new SelfOpPreExpr(op, lv, new Position(ctx.getStart().getLine()));

    }

    @Override
    public AST visitLogBinary(MangoParser.LogBinaryContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr(0));
        ExprStmt rhs = (ExprStmt) visit(ctx.expr(1));

        BinaryOp op = null;
        switch (ctx.op.getType()) {
            case MangoParser.LESS:
                op = BinaryOp.slt;
                break;
            case MangoParser.LARGE:
                op = BinaryOp.sgt;
                break;
            case MangoParser.LEQ:
                op = BinaryOp.sle;
                break;
            case MangoParser.GEQ:
                op = BinaryOp.sge;
                break;
            case MangoParser.EQ:
                op = BinaryOp.seq;
                break;
            case MangoParser.NEQ:
                op = BinaryOp.sne;
                break;
//            case MangoParser.LOG_AND:
//                op = LogBinaryOp.LOG_AND;
//                break;
//            case MangoParser.LOG_OR:
//                op = LogBinaryOp.LOG_OR;
//                break;
        }
        switch (ctx.op.getType()) {
            case MangoParser.EQ:
                if (!(suit(SymbolTable.INT, lhs.getType()) &&
                        suit(SymbolTable.INT, rhs.getType())) &&
                        !(suit(SymbolTable.STRING, lhs.getType()) &&
                                suit(SymbolTable.STRING, rhs.getType())) &&
                        !((lhs.getType() instanceof ClassType) && rhs.getType() == null) &&
                        !(suit(SymbolTable.BOOL, lhs.getType()) &&
                                suit(SymbolTable.BOOL, rhs.getType()))) {

                    System.err.println("line " + ctx.getStart().getLine() + ": Logical operation on wrong operands <" + ctx.getText() + ">");
                    throw new SemanticError();
                }
                if (suit(SymbolTable.STRING, lhs.getType())) {

                    if (lhs instanceof StringExpr && rhs instanceof StringExpr) {
                        if (((StringExpr) lhs).getText().equals(((StringExpr) rhs).getText())) {
                            return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                        } else {
                            return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                        }
                    }

                    List<ExprStmt> AP = new LinkedList<>();
                    AP.add(lhs);
                    AP.add(rhs);
                    try {
                        return new CallExpr((FuncSymbol) global.resolve(getName("stringIsEqual")), AP, new Position(ctx.getStart().getLine()));
                    } catch (Undefined e) {
                        throw new Bug_FuncNotDefine();
                    }
                }
                break;
            case MangoParser.LARGE:
            case MangoParser.LEQ:
            case MangoParser.GEQ:
            case MangoParser.NEQ:
            case MangoParser.LESS: {
                if (!(suit(SymbolTable.INT, lhs.getType()) &&
                        suit(SymbolTable.INT, rhs.getType())) &&
                        !(suit(SymbolTable.STRING, lhs.getType()) &&
                                suit(SymbolTable.STRING, rhs.getType()))) {
                    System.err.println("line " + ctx.getStart().getLine() + ": Logical operation on wrong operands <" + ctx.getText() + ">");
                    throw new SemanticError();
                }
                if (suit(SymbolTable.STRING, lhs.getType())) {

                    if (lhs instanceof StringExpr && rhs instanceof StringExpr) {
                        if (((StringExpr) lhs).getText().compareTo(((StringExpr) rhs).getText()) < 0) {
                            return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                        } else {
                            return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                        }
                    }

                    List<ExprStmt> AP = new LinkedList<>();
                    AP.add(lhs);
                    AP.add(rhs);
                    try {
                        switch (ctx.op.getType()) {
                            case MangoParser.LARGE:
                                return new CallExpr((FuncSymbol) global.resolve(getName("stringLarge")), AP, new Position(ctx.getStart().getLine()));
                            case MangoParser.LEQ:
                                return new CallExpr((FuncSymbol) global.resolve(getName("stringLeq")), AP, new Position(ctx.getStart().getLine()));
                            case MangoParser.GEQ:
                                return new CallExpr((FuncSymbol) global.resolve(getName("stringGeq")), AP, new Position(ctx.getStart().getLine()));
                            case MangoParser.NEQ:
                                return new CallExpr((FuncSymbol) global.resolve(getName("stringNeq")), AP, new Position(ctx.getStart().getLine()));
                            case MangoParser.LESS:
                                return new CallExpr((FuncSymbol) global.resolve(getName("stringLess")), AP, new Position(ctx.getStart().getLine()));
                        }
                    } catch (Undefined e) {
                        throw new Bug_FuncNotDefine();
                    }
                }
            }
            break;
//            If the expression is a logical relation expression
            case MangoParser.LOG_AND:
            case MangoParser.LOG_OR: {
                if (!(suit(SymbolTable.BOOL, lhs.getType()) &&
                        suit(SymbolTable.BOOL, rhs.getType()))) {
                    System.err.println("line " + ctx.getStart().getLine() + ": Logical operation on wrong operands " + ctx.getText() + ">");
                    throw new SemanticError();
                }
                if (lhs instanceof BoolExpr && rhs instanceof BoolExpr) {
                    if (ctx.op.getType() == MangoParser.LOG_AND) {
                        if (((BoolExpr) lhs).getValue() && ((BoolExpr) rhs).getValue()) {
                            return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                        } else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                    } else {
                        if (((BoolExpr) lhs).getValue() || ((BoolExpr) rhs).getValue()) {
                            return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                        } else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                    }
                }
                if (ctx.op.getType() == MangoParser.LOG_AND)
                    return new LogRelationExpr(lhs, true, rhs, new Position(ctx.getStart().getLine()));
                else
                    return new LogRelationExpr(lhs, false, rhs, new Position(ctx.getStart().getLine()));
            }
        }
//        if the two sides are all int
        if (lhs instanceof IntExpr && rhs instanceof IntExpr) {
            switch (ctx.op.getType()) {
                case MangoParser.LARGE:
                    if (((IntExpr) lhs).getValue() > ((IntExpr) rhs).getValue())
                        return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                    else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                case MangoParser.LEQ:
                    if (((IntExpr) lhs).getValue() <= ((IntExpr) rhs).getValue())
                        return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                    else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                case MangoParser.GEQ:
                    if (((IntExpr) lhs).getValue() >= ((IntExpr) rhs).getValue())
                        return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                    else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                case MangoParser.NEQ:
                    if (((IntExpr) lhs).getValue() != ((IntExpr) rhs).getValue())
                        return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                    else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                case MangoParser.EQ:
                    if (((IntExpr) lhs).getValue() == ((IntExpr) rhs).getValue())
                        return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                    else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
                case MangoParser.LESS:
                    if (((IntExpr) lhs).getValue() < ((IntExpr) rhs).getValue())
                        return new BoolExpr("true", new Position(ctx.getStart().getLine()));
                    else return new BoolExpr("false", new Position(ctx.getStart().getLine()));
            }
        }
        return new LogBinaryExpr(lhs, op, rhs, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitBinary(MangoParser.BinaryContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr(0));
        ExprStmt rhs = (ExprStmt) visit(ctx.expr(1));
        BinaryOp op = null;
        switch (ctx.op.getType()) {
            case MangoParser.MULT:
                op = BinaryOp.mul;
                break;
            case MangoParser.DIV:
                op = BinaryOp.div;
                break;
            case MangoParser.MOD:
                op = BinaryOp.rem;
                break;
            case MangoParser.PLUS:
                op = BinaryOp.add;
                break;
            case MangoParser.MINUS:
                op = BinaryOp.sub;
                break;
            case MangoParser.SHIFT_L:
                op = BinaryOp.sll;
                break;
            case MangoParser.SHIFT_R:
                op = BinaryOp.sra;
                break;
            case MangoParser.BIT_AND:
                op = BinaryOp.and;
                break;
            case MangoParser.BIT_XOR:
                op = BinaryOp.xor;
                break;
            case MangoParser.BIT_OR:
                op = BinaryOp.or;
                break;
        }
        switch (ctx.op.getType()) {
            case MangoParser.MULT:
            case MangoParser.DIV:
            case MangoParser.MOD:
            case MangoParser.MINUS:
            case MangoParser.SHIFT_L:
            case MangoParser.SHIFT_R:
            case MangoParser.BIT_AND:
            case MangoParser.BIT_XOR:
            case MangoParser.BIT_OR: {
                if (!(suit(SymbolTable.INT, lhs.getType()) &&
                        suit(SymbolTable.INT, rhs.getType()))) {
                    System.err.println("line " + ctx.getStart().getLine() + ": Operation on wrong operands <" + ctx.getText() + ">");
                    throw new SemanticError();
                }
            }
            break;
            case MangoParser.PLUS: {
                if (!(suit(SymbolTable.INT, lhs.getType()) &&
                        suit(SymbolTable.INT, rhs.getType())) &&
                        !(suit(SymbolTable.STRING, lhs.getType()) &&
                                suit(SymbolTable.STRING, rhs.getType()))) {
                    System.err.println("line " + ctx.getStart().getLine() + ": Operation on wrong operands <" + ctx.getText() + ">");
                    throw new SemanticError();
                }
                if (suit(SymbolTable.STRING, lhs.getType())) {
                    if (lhs instanceof StringExpr && rhs instanceof StringExpr) {
                        return new StringExpr(((StringExpr) lhs).getText() + ((StringExpr) rhs).getText(), new Position(ctx.getStart().getLine()));
                    }
                    List<ExprStmt> AP = new LinkedList<>();
                    AP.add(lhs);
                    AP.add(rhs);
                    try {
                        return new CallExpr((FuncSymbol) global.resolve(getName("stringConcatenate")), AP, new Position(ctx.getStart().getLine()));
                    } catch (Undefined e) {
                        throw new Bug_FuncNotDefine();
                    }
                }
            }
        }

        if (lhs instanceof IntExpr && rhs instanceof IntExpr) {
            switch (ctx.op.getType()) {
                case MangoParser.MULT:
                    return new IntExpr(((IntExpr) lhs).getValue() * ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.DIV:
                    return new IntExpr(((IntExpr) lhs).getValue() / ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.MOD:
                    return new IntExpr(((IntExpr) lhs).getValue() % ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.MINUS:
                    return new IntExpr(((IntExpr) lhs).getValue() - ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.SHIFT_L:
                    return new IntExpr(((IntExpr) lhs).getValue() << ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.SHIFT_R:
                    return new IntExpr(((IntExpr) lhs).getValue() >> ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.BIT_AND:
                    return new IntExpr(((IntExpr) lhs).getValue() & ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.BIT_XOR:
                    return new IntExpr(((IntExpr) lhs).getValue() ^ ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.BIT_OR:
                    return new IntExpr(((IntExpr) lhs).getValue() | ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
                case MangoParser.PLUS:
                    return new IntExpr(((IntExpr) lhs).getValue() + ((IntExpr) rhs).getValue(), new Position(ctx.getStart().getLine()));
            }
        }
        return new CalcBinaryExpr(lhs, op, rhs, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitSign(MangoParser.SignContext ctx) {
        ExprStmt base = (ExprStmt) visit(ctx.expr());
        if (!base.getType().isSuitableAs(SymbolTable.INT)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong sign operation <" + ctx.expr().getText() + ">");
            throw new SemanticError();
        }
        Boolean op;
        if (ctx.op.getType() == MangoParser.PLUS) op = true;
        else op = false;
        return new SignExpr(op, base, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitAssign(MangoParser.AssignContext ctx) {
        ExprStmt rhs = (ExprStmt) visit(ctx.expr(1));
        ExprStmt lv = (ExprStmt) visit(ctx.expr(0));
        if (!(lv instanceof LValue)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong assignment operation on non-Lvalue <" + ctx.expr(0).getText() + ">");
            throw new SemanticError();
        }
        if (!suit(lv.getType(), rhs.getType())) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong type matching on assignment <" + ctx.getText() + ">");
            throw new SemanticError();
        }
        return new AssignExpr(lv, rhs, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitBitNot(MangoParser.BitNotContext ctx) {
        ExprStmt context = (ExprStmt) visit(ctx.expr());
        if (context instanceof IntExpr) {
            return new IntExpr(~((IntExpr) context).getValue(), new Position(ctx.getStart().getLine()));
        }
        if (!context.getType().isSuitableAs(SymbolTable.INT)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Invalid operation operand <" + ctx.expr().getText() + ">");
            throw new SemanticError();
        }
        return new BitNotExpr(context, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitFieldAccess(MangoParser.FieldAccessContext ctx) {
        ExprStmt lhs = (ExprStmt) visit(ctx.expr());
        if (!(lhs.getType() instanceof ClassType)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong class field accessing");
            throw new SemanticError();
        }
//        if (!(lhs instanceof LValue)) {
//            System.err.println("line " + ctx.getStart().getLine() + ": Wrong operation on non-Lvalue <" + ctx.getText() + ">");
//            throw new SemanticError();
//        }
        Name field = getName(lhs.getType().toString() +
                '.' + ctx.ID().getText());
        VarSymbol varInfo;
        try {
            varInfo = (VarSymbol) global.resolve(field);
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined class field <" + ctx.getText() + ">");
            throw new SemanticError();
        }
        return new FieldAccessExpr(varInfo.getType(), lhs, field,
                ((ClassType) lhs.getType()).getShift(field), new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitClassFuncAccess(MangoParser.ClassFuncAccessContext ctx) {
        // It will also recognize builtin String and Array Function
        ExprStmt lhs = (ExprStmt) visit(ctx.expr());
        if (!((lhs.getType() instanceof ClassType) || (lhs.getType() == SymbolTable.STRING) || (lhs.getType() instanceof ArrayType))) {
            System.err.println("line " + ctx.getStart().getLine() + ": Wrong class function access");
            throw new SemanticError();
        }
        Name func;
        if (lhs.getType() instanceof ArrayType) {
            func = getName("_array." + ctx.ID().getText());
        } else func = getName(lhs.getType() + "." + ctx.ID().getText());
        FuncSymbol funcInfo = null;
        try {
            funcInfo = (FuncSymbol) global.resolve(func);
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined class function <" + func + ">");
        }

        List<Type> APT = new LinkedList<>();
        LinkedList<ExprStmt> AP = new LinkedList<>();
        ListIterator<ExprStmt> APItr = AP.listIterator(0);
        APT.add(lhs.getType());
        APItr.add(lhs);
        if (ctx.exprList() != null) {
            List<MangoParser.ExprContext> APc = ctx.exprList().expr();
            ListIterator<MangoParser.ExprContext> APcItr = APc.listIterator(0);
            while (APcItr.hasNext()) {
                AP.addLast((ExprStmt) visit(APcItr.next()));
                APT.add(AP.getLast().getType());
            }
//            System.out.println("check: " + ctx.getText());
//            for (ExprStmt e: AP){
//                System.out.print(e + " ");
//            }
//            System.out.println();
        }
        // compare AP and FP
        if (!funcInfo.isValidParameters(APT)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Function call parameter mismatching, see function declaration at <" + funcInfo.getName() + ">");
            throw new SemanticError();
        }
        if (funcInfo.getReturnType() == null) {
//            System.out.println("null return type!!!!!!!!!!!");
            return new CallExpr(funcInfo, AP, new Position(ctx.getStart().getLine()), null);
        }

        return new CallExpr(funcInfo, AP, new Position(ctx.getStart().getLine()));
//        return new ClassFuncAccessExpr(lhs, funcInfo, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitArrayCreate(MangoParser.ArrayCreateContext ctx) {
        ArrayType base;
        try {
            base = (ArrayType) parseType(ctx.getText().substring(3), global);
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined type to create new variable");
            throw new SemanticError();
        }
        ExprStmt index = (ExprStmt) visit(ctx.expr());
        if (!index.getType().isSuitableAs(SymbolTable.INT)) {
            System.err.println("line " + ctx.getStart().getLine() + ": Unexpected indexing <" + ctx.expr().getText() + ">");
            throw new SemanticError();
        }
        return new ArrayCreationExpr(base, index, new Position(ctx.getStart().getLine()));
    }

    @Override
    public AST visitAtomCreate(MangoParser.AtomCreateContext ctx) {
        Type base;
        try {
            base = global.lookUpType(ctx.atom().getText());
        } catch (Undefined err) {
            System.err.println("line " + ctx.getStart().getLine() + ": Using undefined type to create new variable");
            throw new SemanticError();
        }
        if (!(base instanceof ClassType)) {
            System.err.println("line " + ctx.getStart().getLine() + ": New a variable of built-in Type");
            throw new SemanticError();
        }
        return new AtomCreationExpr((ClassType) base, new Position(ctx.getStart().getLine()));
    }

//    @Override
//    public AST visitExprList(MangoParser.ExprListContext ctx) {
//
//        return visitChildren(ctx);
//    }

    @Override
    public AST visitClassDecl(MangoParser.ClassDeclContext ctx) {
        nowClass = ctx.ID().getText();
        List<VarDecl> variables = null;
        List<FuncDecl> functions = null;

        List<MangoParser.MemberDeclContext> decls = ctx.classBlock().memberDecl();
        ListIterator<MangoParser.MemberDeclContext> declsItr = decls.listIterator();

        while (declsItr.hasNext()) {
            Decl temp = (Decl) visit(declsItr.next());
            if (temp instanceof VarDecl) {
                if (variables == null) variables = new LinkedList<>();
                variables.add((VarDecl) temp);
            } else if (temp instanceof FuncDecl) {
                if (functions == null) functions = new LinkedList<>();
                functions.add((FuncDecl) temp);
            } else throw new Bug_WrongReturn();
        }
        ClassDecl classDecl;
        try {
            classDecl = new ClassDecl(variables, functions,
                    (ClassType) global.lookUpType(nowClass), new Position(ctx.getStart().getLine()));
        } catch (Undefined err) {
            throw new Bug_TextError();
        }
        nowClass = null;
        return classDecl;
    }

//    @Override
//    public AST visitClassBlock(MangoParser.ClassBlockContext ctx) {
//        return visitChildren(ctx);
//    }


    // remember to return a VarDecl
    @Override
    public AST visitClassField(MangoParser.ClassFieldContext ctx) {
        VarSymbol classVar;
        try {
            classVar = (VarSymbol) global.resolve(getName(nowClass + '.' + ctx.ID().getText()));
        } catch (Undefined err) {
            throw new Bug_TextError();
        }
        return new VarDecl(classVar, null, new Position(ctx.getStart().getLine()));
    }


//    @Override
//    public AST visitClassFunction(MangoParser.ClassFunctionContext ctx) {
//        return visitChildren(ctx);
//    }
private void parseStringConcatenation(List<Stmt> stmts, ExprStmt ast) {
    if ((ast instanceof CallExpr) && ((CallExpr) ast).getFuncInfo().getName().toString().equals("_stringConcatenate")) {
        parseStringConcatenation(stmts, ((CallExpr) ast).getActualParameter().get(0));
//            stmts.add(((CallExpr) ast).getActualParameter().get(1));
        if (((CallExpr) ast).getActualParameter().get(1) instanceof CallExpr &&
                ((CallExpr) ((CallExpr) ast).getActualParameter().get(1)).getFuncInfo().getName().toString().equals("_toString")) {
            stmts.add(new CallExpr(SymbolTable.printInt, Arrays.asList(((CallExpr) ((CallExpr) ast).getActualParameter().get(1)).getActualParameter().get(0)), ast.getPosition(), null));
            return;
        }
        stmts.add(new CallExpr(SymbolTable.print, Arrays.asList(((CallExpr) ast).getActualParameter().get(1)), ast.getPosition(), null));
    } else {
        if (ast instanceof CallExpr && ((CallExpr) ast).getFuncInfo().getName().toString().equals("_toString")) {
            stmts.add(new CallExpr(SymbolTable.printInt, Arrays.asList(((CallExpr) ast).getActualParameter().get(0)), ast.getPosition(), null));
            return;
        }
        stmts.add(new CallExpr(SymbolTable.print, Arrays.asList(ast), ast.getPosition(), null));
        return;
    }
}
}